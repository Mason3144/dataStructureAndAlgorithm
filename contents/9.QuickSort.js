// /*
// quick sort
// 재귀를 이용하여 데이터를 분할
// 배열이 0~1개의 아이템이 남을때까지 분할 후 개별적으로 정렬

// pivot 포인트라는 하나의 아이템을 지정
// 지정된 아이템보다 작은숫자를 왼쪽으로 옮김
// 그렇게되면 지정된 아이템만은 바른 위치가됨
// 이과정을 왼쪽과 오른쪽에 반복

// [5,2,1,8,4,7,6,3] 5를 피벗포인트로 지정한후 정렬
// [2,1,4,3,5,8,7,6] 다음 5를 기준으로 2를 피벗포인트로 지정후 같은 작업을 수행
// [1,2,4,3,5,8,7,6] 다음 1을 기준으로 작업을 수행하지만 결과값이 같으므로 4를 수행
// [1,2,3,4,5,8,7,6] 첫 피벗포인트인 5를 기준으로 왼쪽은 정렬이 다되었으므로 오른쪽인 8을 피벗포인트로지정
// [1,2,3,4,5,7,6,8] 다음 7을 피벗으로 지정
// [1,2,3,4,5,6,7,8] 정렬완료

// */
// /*
// 첫번째를 피벗으로 지정
// 다음 아이템들을 비교하며 피벗보다 작은 아이템을 피벗의 앞에다가 옴겨놓고 카운트함
// 계속 비교하며 카운트된 값과 피벗의 위치를 바꿈
// 기존 피벗의 왼쪽 아이템들을 반복하여 진행
// 이후 첫번째 피벗의 오른쪽 아이템들을 반복하여 진행
// */

// /*
// 피벗 헬퍼
// 피벗보다 작은값은 모두 왼쪽 큰값은 오른쪽
// 헬퍼가 제자리에서 수행해야된다는것, 새배열을 만들면 안되며 피벗 인덱스를 리턴해야됨

// 피벗 함수를 만들고 피벗의 인덱스를 반환하며 배열의 순서는 바뀌어 잇어야함

// 배열, 시작인덱스, 끝인덱스 3개의 인수를 받는 함수작성
// 시작인덱스는 0, 끝인덱스는 배열길이 -1
// 피벗을 선택, 피벗 인덱스를 변수로 저장
// 루프를 돌려 피벗보다 낮은수는 피벗의 앞으로 피벗보다 높은수는 그대로 둔후 카운터저장
// 모든수를 비교후 카운터인덱스와 피벗의 인덱스 교환
// 카운터 인덱스가 곧 피벗의 인덱스이므로 그 값을 반환 반환

// */

function pivot(arr, start = 0, end = arr.length - 1) {
  let pivotIndex = start;
  let swap;
  for (let i = start + 1; i <= end; i++) {
    if (arr[pivotIndex] > arr[i] || arr[pivotIndex] === arr[i]) {
      pivotIndex++;
      swap = arr[i];
      arr[i] = arr[pivotIndex];
      arr[pivotIndex] = swap;
    }
  }
  swap = arr[pivotIndex];
  arr[pivotIndex] = arr[start];
  arr[start] = swap;

  return pivotIndex;
}

// console.log(pivot([4, 2, 3, 6, 1, 8, 7, 5]));

/*
  피벗 함수 호출
  재귀적으로 계속 호출하여 피벗포인트의 왼쪽과 오른쪽을 다시 정렬
  새로운 배열을 만들지 않음
  
  베이스케이스 하위 배열에 항목 하나가 있는지 확인
  
  */

function quickSort(arr, left = 0, right = arr.length - 1) {
  if (left < right) {
    let pivotIndex = pivot(arr, left, right);
    quickSort(arr, left, pivotIndex - 1);
    quickSort(arr, pivotIndex + 1, right);
  }

  return arr;
}

console.log(quickSort([0, -2, 3, 4, 1, 2, -1]));

/*
  빅오
  최상
  피벗을 기준으로 큰값들과 작은값들을 반씩 나눈다 16개의 아이템을 하나의 아이템이 남을때까지 분해를할경우
  2**4이므로 O(log n)이 된다.
  하지만 각각 분해하는 단계마다 O(n)번의 비교를 수행하므로 최종적으로  O(n log n)이 된다.
  
  최악
  만약 아이템 16개의 잘 정렬된 배열 [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16]이 주어젔을때
  분해단계에서 16번의 작업을 수행하게 된다. 즉 시간복잡도는 O(n)이 된다.
  그후 비교단계의 경우 O(n)이므로 최종 시간복잡도는  O(n**2)이 된다.
  
  이렇게 잘 정렬된 배열을 사용할경우 pivot을 첫 아이템이아닌 배열 중간에 있는 아이템으로 정할경우
  시간복잡도는 다시 O(n log n)이 된다.
  
  */
